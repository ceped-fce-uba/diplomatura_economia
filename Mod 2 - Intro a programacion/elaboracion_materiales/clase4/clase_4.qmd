---
title: "Clase 4 - Visualización de Datos Avanzada"
subtitle: "Diplomatura Problemas Actuales de la Economía, el Empleo y el Comercio (CEPED - FCE - UBA)"
author-title: "DOCENTES:" 
authors:
  - name: Vladimiro S. Torres
  - name: Juan Camilo Gutman
output-file: "Clase 4 - Visualizacion de Datos Avanzada" 
format:
  html:
    embed-resources: true
    code-tools: false
    code-copy: false
    toc: true
    toc-location: left
    theme: 
      light: ../assets/practica_claro.scss
      dark: ../assets/practica_oscuro.scss
    fig-width: 8
    fig-height: 5
    fig-format: retina
    warning: false
    message: false
    echo: true
execute:
  freeze: auto
editor: source
include-after-body: ../assets/footer.html
---

```{r}
#| echo: false
#| purl: false

library(tidyverse)
library(readxl)
library(lubridate)      # Para manejar fechas
library(plotly)         # Interactive plots
library(ggthemes)
library(gt)

options(scipen=999)
```

# Complejizar la visualización

En este última clase se avanzará sobre la complejización de la visualización de datos en R, entendiendo que las principales fortalezas de ello se encuentra en la posibilidad de automatizar complejas visualizaciones sobre un conjunto no menor de datos. A su vez, el entorno de R permite explorar cambios drásticos sobre la visualización, vinculados al formato y la geometría del dato visualizado, tan solo con acotadas líneas de código.

En una primera instancia se avanzará sobre la visualización más compleja de series, así como de puntos, para luego avanzar en la visualización de frecuencias, distribuciones y densidad.

## Visualizar Series

Al final de la última clase les mostramos el siguiente gráfico:

```{r}
#| warning: FALSE

library(tidyverse)

SIPA <- read_csv("bases/base_sipa.csv", show_col_types = FALSE)
ipc_mensual <- read_xlsx("../clase2/bases/ipc_ceped_data.xlsx")

SIPA <- SIPA %>% 
  mutate(Periodo = as.Date(Periodo),
         Anio = year(Periodo),
         Mes = month(Periodo),
         Trimestre = quarter(Periodo))

ipc_mensual <- ipc_mensual %>% 
  mutate(fecha = as.Date(fecha))

remuneracion_media <- SIPA %>% 
  filter(Variable == "Remuneración promedio - sin estacionalidad") %>% 
  mutate(indice_remuneraciones = Valor/Valor[Periodo == "2009-01-01"]*100)

ipc_mensual <- ipc_mensual %>% 
  mutate(indice_ipc_2009 = valor/valor[fecha == "2009-01-01"]*100)

remuneracion_real <- remuneracion_media %>%
  left_join(ipc_mensual, by = c("Periodo" = "fecha"))

remuneracion_real <- remuneracion_real %>% 
  mutate(indice_real = indice_remuneraciones/indice_ipc_2009*100,
         Trimestre        = quarter(Periodo)) %>% 
  select(Periodo, Anio = ANO4, Trimestre, Mes = sub, indice_real) 

graf_remun <- remuneracion_real %>% 
  ggplot(aes(x = Periodo, y = indice_real)) +
  geom_line(color = "#104E8B", size = 1) +
  theme_classic() +
  labs(title = "Remuneración Real Asal. Reg. del Sec. Privado",
       subtitle = "Total País. Sin estacionalidad. (ene-2009 = 100)",
       y = "",
       x = "",
       caption = "Fuente: Sistema Integrado Previsional Argentino (SIPA)")

graf_remun
```

Podemos empezar por poner un tema especial. En este caso, uno del paquete `ggthemes`:

```{r}
library(ggthemes)

graf_remun <- graf_remun +
  theme_fivethirtyeight() 

graf_remun
```

Siempre es interesante agregar marcas contextuales. Por ejemplo, una línea discontinua horizontal y otra punteada, vertical.

```{r}
graf_remun <- graf_remun +
  
  geom_hline(yintercept = 100, linetype = "dashed", color = "gray50", size = 0.8) +
  
  geom_vline(xintercept = as.Date("2020-03-20"), linetype = "dotted", color = "red", size = 0.7)

graf_remun
```

Un poco más avanzado, pero pueden hacer anotaciones en el gráfico. Lo más complicado es dar las coordenadas, pero para eso conviene ir probando:

```{r}
graf_remun <- graf_remun +
  annotate("text", x = as.Date("2020-03-20"), y = max(remuneracion_real$indice_real, na.rm = TRUE), 
         label = "Inicio Pandemia", hjust = -0.1, vjust = 7, size = 3)

graf_remun
```

Pueden también ajustarse los llamados "ticks" (o marcas de graduación) de los ejes. Éstos son pequeñas marcas en los ejes vertical u horizontal que sirven de referencia para los valores del gráfico. Las funciones de ajuste más usadas son `scale_x_continuos()` o `scale_y_continuos()` pero que son algo más confusas. Empecemos por algo simple:

```{r}
graf_remun <- graf_remun +
scale_x_date(date_breaks = "1 year", date_labels = "%Y")

graf_remun
```

Algo típico es voltear las etiquetas de las marcas de graduación a 45°, muy útil cuando se tiene cortes muy frecuentes:

```{r}
graf_remun <- graf_remun +
  theme(axis.text.x = element_text(angle = 45,
                                  hjust = 1)
        )
  
graf_remun
```

Para terminar, aquí cómo pueden añadir áreas sombreadas para destacar períodos específicos:

```{r}
graf_remun <- graf_remun +
  
annotate("rect", 
       xmin = as.Date("2015-09-01"), xmax = as.Date("2020-02-01"),
       ymin = -Inf, ymax = Inf, 
       fill = "yellow", alpha = 0.2) +
  
annotate("text", x = as.Date("2017-12-10"), y = max(remuneracion_real$indice_real, na.rm = TRUE), 
         label = "Retroceso previo a la pandemia", vjust = 0, size = 3)

graf_remun
```

## Visualizar Puntos

En la práctica de la clase anterior vimos el siguiente gráfico:

```{r}
library(gapminder)  
library(ggplot2)    

gapminder_2007 <- gapminder %>% filter(year == 2007)

ggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point() +  
  labs(
    title = "Esperanza de vida vs. PBI per Capita (2007)",
    x = "PBI per Capita (en escala logarítmica)",
    y = "Esperanza de vida (en años)"
  ) +
  scale_x_log10() +  # Escala logarítmica para el PBI
  theme_classic()
```

En breve vamos a ver una manera de complejizar esta visualización. Pero primero, los comentarios que les prometimos sobre escalas logarítmicas:

-   Distancias iguales representan multiplicaciones iguales, no sumas iguales:
    -   En una escala logarítmica base 10, el espacio entre cada potencia de 10 (1, 10, 100, 1000, etc.) es visualmente idéntico.
    -   En nuestro caso, por ejemplo, la diferencia entre 300 y 1.000 ocupa el mismo espacio que entre 3.000 y 10.000

```{r}
library(gapminder)
library(ggplot2)

ggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, 
                          size = pop, color = continent)) +
  geom_point(alpha = 0.7) +  # Puntos con transparencia, clave por la superposición
  scale_x_log10() +  # Escala logarítmica para GDP per capita
  labs(
    title = "Esperanza de vida vs. PBI per Capita (2007)",
    x = "PBI per Capita (en escala logarítmica)",
    y = "Esperanza de vida (en años)",
    color = "Continente"
  ) +
  theme_classic()
```

## Visualizar Composición

### Gráficos de áreas apiladas

```{r}

# Leer los datos
expo_mineras <- read_csv("bases/expo_mineras_por_grupo.csv")


expo_mineras <- expo_mineras %>% 
  group_by(grupo_nuevo) %>%
  mutate(total = sum(expo_grupo)) %>%
  ungroup() %>%
  mutate(grupo_nuevo = fct_reorder(grupo_nuevo, total, .desc = TRUE))

ggplot(expo_mineras, aes(x = anio, y = expo_grupo, fill = grupo_nuevo)) +
  # bordes finos para distinguir los grupos
  geom_area(color = "white", size = 0.1, alpha = 0.85) +
  
  # paleta de colores
  scale_fill_tableau() +
  
    scale_y_continuous(
    labels = function(x) paste0("$", x / 1000000, "M"),
    expand = c(0, 0)
  ) +

  scale_x_continuous(
    breaks = seq(1994, 2022, by = 4),
    expand = c(0, 0)
  ) +

  labs(
    title = "Exportaciones mineras argentinas por grupo de minerales (1994-2022)",
    x = "Año",
    y = "Miles de millones USD",
    fill = "Mineral"
  ) -> graf_expo_mine # Esta forma de asignar puede que también se la encuentren

graf_expo_mine

```

Una sola línea de código y ya lo hacemos interactivo:

```{r}
ggplotly(graf_expo_mine)
```

Lo cierto es que si quieren entrar en el mundo de las visualizaciones interactivas tienen que explorar `plotly`. No siempre funciona bien `ggplotly()` para traducir de una librería a otra.

## Visualizar la Dispersión y las Diferencias

Para avanzar sobre medidas vinculadas a la dispersión y las diferencias, se hará uso de la [base de datos](https://www.indec.gob.ar/indec/web/Institucional-Indec-BasesDeDatos-9) proveniente de la [Encuesta Nacional de Uso del Tiempo (ENUT)](https://www.indec.gob.ar/indec/web/Nivel4-Tema-4-31-117).

Entre octubre y diciembre de 2021, el INDEC realizó la Encuesta Nacional de Uso del Tiempo, que busca caracterizar la vida de personas de distintas edades y el tiempo que le dedican a las actividades que realizan dentro y fuera de los hogares. El relevamiento se llevó a cabo en 28.520 viviendas seleccionadas de áreas urbanas de todo el país.

Por tanto, se procede a levantar la base de datos correspondiente a la encuesta:

```{r}
enut <- read.table("bases/enut2021_base.txt",
                  header = TRUE,
                  sep = "|",
                  dec = ".")
```

Notar que el tipo de base es `.txr`, un formato no utilizado hasta el momento, pero muy habitual en las bases de datos provistas por el INDEC. En este sentido, un formato distinto requiere funciones distintas, para este caso se utilizó la función `read.table()`. Al mismo tiempo, es muy importante notar que este tipo de formatos no tienen estandarizados el tipo de separado entre una variable u otra, ni el signo de puntuación que diferencia el entero del decimal. Es por ello que se requiere utilizar los parámetros de la función para indicarle a R que signo separa una variable de otra y cuál el entero del decimal.

De este modo, `header = TRUE` nos indica que R muestre el título de cada columna (nombre de variable), `sep = "|` es una indicación para que R interprete que el signo \| separa una variable de otra (en otros casos podría ser una coma o un punto y coma), y por último `dec = "."` hace referencia a que las variables numéricas se separan entre enteros y decimales mediante puntos.

Ahora si, se procede a visualizar la información de la encuesta. Para trabajar con ella, siempre es recomendable contar con el [Diccionario de Registros](https://www.indec.gob.ar/ftp/cuadros/menusuperior/enut/enut2021_diccionario_registros.xlsx), el cual nos indicara a qué corresponde cada nombre de variable y que tipo de contenido yacen en estas.

En dicha exploración, puede encontrarse, por ejemplo, que la variable `TIPO_HOGAR_DTOTAL` refleja la tipología de hogar según demandante de cuidado: 0 para hogares sin personas demandantes de cuidado, 1 para aquellos hogares donde hay al menos un demandante de cuidado.

```{r}
ggplot(enut, aes())
```

## Visualizar la distribución, la densidad y las frecuencias

### Complejización de la distribución: graficos de violin vs. boxplot

gráficos de densidad: enut

```{r}
#| eval: FALSE

enut
```

### Recursos adicionales

Para quienes quieran profundizar en estos conceptos:

-   La clase pasada les hablamos un poco sobre números índice (y hoy seguimos trabajando sobre el índice de remuneraciones reales). Los números índices son en general una forma excelente de visualizar y son especialmente potentes para graficar múltiples series. Más sobre esto y otras cosas en estas dos excelentes entradas de blog: <https://www.storytellingwithdata.com/blog/2016/2/1/be-gone-dual-y-axis>, <https://www.datawrapper.de/blog/dualaxis>

-   QCBS R Workshop Series (2023). *Workshop 3: Introduction to data visualisation with ggplot2*. <https://r.qcbs.ca/workshop03/book-en/>

-   The R Graph Gallery. <https://r-graph-gallery.com/>

-   From data to viz. <https://www.data-to-viz.com/>

-   Dataviz Inspiration <https://www.dataviz-inspiration.com/>

## Bibliografía {.unnumbered}

```{=html}
<div id="refs" class="references csl-bib-body hanging-indent">

  <div id="ref-wickham2019" class="csl-entry">
    Wickham, H., &amp; Grolemund, G. (2023). <i>R for Data Science (2nd ed)</i>. O'Reilly Media.
  </div>

  <div id="ref-dataviz" class="csl-entry">
    DataViz Inspiration. (n.d.). RetrievedRecuperado de <a href="https://www.dataviz-inspiration.com/">https://www.dataviz-inspiration.com/</a>
  </div>

</div>
```
